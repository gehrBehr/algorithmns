
\documentclass[12pt]{amsart}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{amsmath}
\usepackage{amsaddr}
\usepackage{dirtytalk}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{enumerate}

\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{stringcolor}{rgb}{0.7,0.23,0.36}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{keycolor}{rgb}{0.007,0.01,1.0}
\definecolor{itemcolor}{rgb}{0.01,0.0,0.49}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,      
    urlcolor=blue,
}
 
\lstdefinestyle{mystyle}{
    %backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{keycolor},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{stringcolor},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\lstdefinelanguage{Swift}{
  keywords={associatedtype, class, deinit, enum, extension, func, import, init, inout, internal, let, operator, private, protocol, public, static, struct, subscript, typealias, var, break, case, continue, default, defer, do, else, fallthrough, for, guard, if, in, repeat, return, switch, where, while, as, catch, dynamicType, false, is, nil, rethrows, super, self, Self, throw, throws, true, try, associativity, convenience, dynamic, didSet, final, get, infix, indirect, lazy, left, mutating, none, nonmutating, optional, override, postfix, precedence, prefix, Protocol, required, right, set, Type, unowned, weak, willSet},
  ndkeywords={class, export, boolean, throw, implements, import, this},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

\lstset{emph={Int,count,abs,repeating,Array}, emphstyle=\color{itemcolor}}


\title{Week 07}

\date{\today}

\lstset{style=mystyle}

%%% BEGIN DOCUMENT
\begin{document}
\maketitle

\section{Preparation for Assignment}
If, and \textit{only if} you can truthfully assert the truthfulness of each statement below are you ready to start the exercises.
\subsection {Reading Comprehension Self-Check}
\begin{itemize}
\item I know that \textbf{input enhancement} is the idea of preprocessing some or all of a problem\textquoteright s input, and storing the additional information obtained to accelerate solving the problem afterward.
 \item I know why it is \textbf{false} to say that the two principal resources of
    time and space compete with each other in \textbf{all} design situations.
 \item We know why sorting by distribution counting is more efficient than
    quicksort.
 \item I know why it is \textbf{false} to say that data compression is a typical
    space-time tradeoff.
 \item I know that \textbf{prestructuring} creates structures that allow faster
    and/or more flexible access to data.
 \item I know why it is \textbf{false} to say that these pre-structured structures
    typically use less space than otherwise required.
 \item I know that hashing enables, on average, constant-time searching,
    insertion, and deletion.

\end{itemize}
\subsection{Memory Self-Check}
Which hash function is better for a key that is a character string? (The
  parameter m is the modulus, the size of the hash table.)
\begin{itemize}
	\item hash-function-1, or
	\item hash-function-2?
\end{itemize}

\lstinputlisting{../support_files/hashes.lsp}%file name and location

 \section{Week 07 Exercises}
\subsection{ Exercise 1 on page 274} 
\subitem
\subitem A.\\
 \begin{tabular}{|c|l |c|c|c|c|c|c|c|c|c|}
\hline
    &0  &1 &2 &3 &4 &5 &6 &7 &8 &9 \\
    \hline
    &  &56 & & & & & & &30 &20   \\
    \hline
    &  && & & & & & &19 &75   \\
    \hline
    &  & & & & & & & & &31   \\
    \hline
   
    
\end{tabular}
\subitem B. find the largest number of key comparisons in a successful search in this table.
Searching for K = 31, the number is 3.
\subitem C. 1.7 or 1.66 rounded up

\subsection{ Exercise 2 on page 274} 
\subitem A.\\
 \begin{tabular}{|c|l |c|c|c|c|c|c|c|c|c|c|}
\hline
    &0  &1 &2 &3 &4 &5 &6 &7 &8 &9 &10 \\
    \hline
    &    &  &   &  &   &   &   & &30 & &   \\
    \hline
    &  &  &  &  &  &  &  &  &30  &20 &   \\
    \hline
    &  &56 & & & & & & &30 &20 &   \\
    \hline
   & & 56& & & & & & &30 &20 &75\\
   \hline
    &31 &56 & & & & & & &30 &20 &75\\
   \hline
    &31 &56 &19 & & & & & &30 &20 &75\\
   \hline

    
\end{tabular}
\subitem B.
\subitem C.

\subsection{Exercise 3 on page 275} 
\subitem The number of different values would be obviously limited by the size of the alphabet 26 spaces. Besides, it is usually not the case that the probability of a word to start with a particular letter is the same for all the letters. 
\subsection{Exercise 4 on page 275} 
The probability of all n keys to be hashed to a particular address is equal to (1/m)n. Since there are m different addresses, the answer is

($\frac{1}{m}$ )$^n$  * m = $\frac{1/(m$^{n-1nil}$)}$.

\subsection{Exercise 3 on page 279} 
\subitem On page 278 it gives us this inequality "upper bound on the height h of the B-tree of order m with n nodes:"

\subsection{Exercise 6 on page 279}


\section{Week 07 Problems}
\subsection{Not in the Book}
The birthday problem is implemented in the following code. Study it, then
  answer the question, why does this code not give 23 as the answer?
\lstinputlisting{../support_files/birthday.lsp}

\end{document}